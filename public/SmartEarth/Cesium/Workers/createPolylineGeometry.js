define(["./defaultValue-69ee94f4","./Matrix2-52f9f880","./ArcType-e1641d8d","./arrayRemoveDuplicates-fe254feb","./Transforms-3e1dc9c2","./Color-6b5fa738","./ComponentDatatype-a9820060","./RuntimeError-ac440aa5","./GeometryAttribute-c774c37f","./GeometryAttributes-1b4134a9","./IndexDatatype-1cbc8622","./PolylinePipeline-96d5682f","./VertexFormat-e68722dd","./PixelFormat-9ceadbf3","./WebGLConstants-f63312fc","./_commonjsHelpers-3aae1032-15991586","./combine-0259f56f","./EllipsoidGeodesic-00b2a9dd","./EllipsoidRhumbLine-683f2cb5","./IntersectionTests-088640d2","./Plane-e5b2f6e0"],(function(e,t,o,r,n,a,i,l,s,c,p,d,u,y,m,f,h,C,g,_,A){"use strict";const E=[];function P(e,t,o,r,n){const i=E;let l;i.length=n;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=r.red,y=r.green,m=r.blue,f=r.alpha;if(a.Color.equals(o,r)){for(l=0;l<n;l++)i[l]=a.Color.clone(o);return i}const h=(u-s)/n,C=(y-c)/n,g=(m-p)/n,_=(f-d)/n;for(l=0;l<n;l++)i[l]=new a.Color(s+l*h,c+l*C,p+l*g,d+l*_);return i}function b(r){const n=(r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT)).positions,l=r.colors,s=e.defaultValue(r.width,1),c=e.defaultValue(r.colorsPerVertex,!1);this._positions=n,this._colors=l,this._width=s,this._colorsPerVertex=c,this._vertexFormat=u.VertexFormat.clone(e.defaultValue(r.vertexFormat,u.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,i.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let p=1+n.length*t.Cartesian3.packedLength;p+=e.defined(l)?1+l.length*a.Color.packedLength:1,this.packedLength=p+t.Ellipsoid.packedLength+u.VertexFormat.packedLength+4}b.pack=function(o,r,n){let i;n=e.defaultValue(n,0);const l=o._positions;let s=l.length;for(r[n++]=s,i=0;i<s;++i,n+=t.Cartesian3.packedLength)t.Cartesian3.pack(l[i],r,n);const c=o._colors;for(s=e.defined(c)?c.length:0,r[n++]=s,i=0;i<s;++i,n+=a.Color.packedLength)a.Color.pack(c[i],r,n);return t.Ellipsoid.pack(o._ellipsoid,r,n),n+=t.Ellipsoid.packedLength,u.VertexFormat.pack(o._vertexFormat,r,n),n+=u.VertexFormat.packedLength,r[n++]=o._width,r[n++]=o._colorsPerVertex?1:0,r[n++]=o._arcType,r[n]=o._granularity,r};const x=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),w=new u.VertexFormat,T={positions:void 0,colors:void 0,ellipsoid:x,vertexFormat:w,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};b.unpack=function(o,r,n){let i;r=e.defaultValue(r,0);let l=o[r++];const s=new Array(l);for(i=0;i<l;++i,r+=t.Cartesian3.packedLength)s[i]=t.Cartesian3.unpack(o,r);l=o[r++];const c=l>0?new Array(l):void 0;for(i=0;i<l;++i,r+=a.Color.packedLength)c[i]=a.Color.unpack(o,r);const p=t.Ellipsoid.unpack(o,r,x);r+=t.Ellipsoid.packedLength;const d=u.VertexFormat.unpack(o,r,w);r+=u.VertexFormat.packedLength;const y=o[r++],m=1===o[r++],f=o[r++],h=o[r];return e.defined(n)?(n._positions=s,n._colors=c,n._ellipsoid=t.Ellipsoid.clone(p,n._ellipsoid),n._vertexFormat=u.VertexFormat.clone(d,n._vertexFormat),n._width=y,n._colorsPerVertex=m,n._arcType=f,n._granularity=h,n):(T.positions=s,T.colors=c,T.width=y,T.colorsPerVertex=m,T.arcType=f,T.granularity=h,new b(T))};const D=new t.Cartesian3,k=new t.Cartesian3,V=new t.Cartesian3,v=new t.Cartesian3;return b.createGeometry=function(l){const u=l._width,y=l._vertexFormat;let m=l._colors;const f=l._colorsPerVertex,h=l._arcType,C=l._granularity,g=l._ellipsoid;let _,A,b;const x=[];let w=r.arrayRemoveDuplicates(l._positions,t.Cartesian3.equalsEpsilon,!1,x);if(e.defined(m)&&x.length>0){let e=0,t=x[0];m=m.filter((function(o,r){let n=!1;return n=f?r===t||0===r&&1===t:r+1===t,!n||(e++,t=x[e],!1)}))}let T=w.length;if(T<2||u<=0)return;if(h===o.ArcType.GEODESIC||h===o.ArcType.RHUMB){let t,r;h===o.ArcType.GEODESIC?(t=i.CesiumMath.chordLength(C,g.maximumRadius),r=d.PolylinePipeline.numberOfPoints):(t=C,r=d.PolylinePipeline.numberOfPointsRhumbLine);const n=d.PolylinePipeline.extractHeights(w,g);if(e.defined(m)){let e=1;for(_=0;_<T-1;++_)e+=r(w[_],w[_+1],t);const o=new Array(e);let n=0;for(_=0;_<T-1;++_){const i=w[_],l=w[_+1],s=m[_],c=r(i,l,t);if(f&&_<e){const e=P(0,0,s,m[_+1],c),t=e.length;for(A=0;A<t;++A)o[n++]=e[A]}else for(A=0;A<c;++A)o[n++]=a.Color.clone(s)}o[n]=a.Color.clone(m[m.length-1]),m=o,E.length=0}w=h===o.ArcType.GEODESIC?d.PolylinePipeline.generateCartesianArc({positions:w,minDistance:t,ellipsoid:g,height:n}):d.PolylinePipeline.generateCartesianRhumbArc({positions:w,granularity:t,ellipsoid:g,height:n})}T=w.length;const F=4*T-4,L=new Float64Array(3*F),G=new Float64Array(3*F),O=new Float64Array(3*F),R=new Float32Array(2*F),I=y.st?new Float32Array(2*F):void 0,S=e.defined(m)?new Uint8Array(4*F):void 0;let B,U=0,N=0,M=0,H=0;for(A=0;A<T;++A){let o,r;0===A?(B=D,t.Cartesian3.subtract(w[0],w[1],B),t.Cartesian3.add(w[0],B,B)):B=w[A-1],t.Cartesian3.clone(B,V),t.Cartesian3.clone(w[A],k),A===T-1?(B=D,t.Cartesian3.subtract(w[T-1],w[T-2],B),t.Cartesian3.add(w[T-1],B,B)):B=w[A+1],t.Cartesian3.clone(B,v),e.defined(S)&&(o=0===A||f?m[A]:m[A-1],A!==T-1&&(r=m[A]));const n=A===T-1?2:4;for(b=0===A?2:0;b<n;++b){t.Cartesian3.pack(k,L,U),t.Cartesian3.pack(V,G,U),t.Cartesian3.pack(v,O,U),U+=3;const n=b-2<0?-1:1;if(R[N++]=b%2*2-1,R[N++]=n*u,y.st&&(I[M++]=A/(T-1),I[M++]=Math.max(R[N-2],0)),e.defined(S)){const e=b<2?o:r;S[H++]=a.Color.floatToByte(e.red),S[H++]=a.Color.floatToByte(e.green),S[H++]=a.Color.floatToByte(e.blue),S[H++]=a.Color.floatToByte(e.alpha)}}}const W=new c.GeometryAttributes;W.position=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:L}),W.prevPosition=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),W.nextPosition=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),W.expandAndWidth=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R}),y.st&&(W.st=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:I})),e.defined(S)&&(W.color=new s.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:S,normalize:!0}));const Y=p.IndexDatatype.createTypedArray(F,6*T-6);let q=0,j=0;const z=T-1;for(A=0;A<z;++A)Y[j++]=q,Y[j++]=q+2,Y[j++]=q+1,Y[j++]=q+1,Y[j++]=q+2,Y[j++]=q+3,q+=4;return new s.Geometry({attributes:W,indices:Y,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:n.BoundingSphere.fromPoints(w),geometryType:s.GeometryType.POLYLINES})},function(o,r){return e.defined(r)&&(o=b.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),b.createGeometry(o)}}));
